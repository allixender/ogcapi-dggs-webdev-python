# generated by fastapi-codegen:
#   filename:  dggs_zone_query-resolved.yaml
#   timestamp: 2021-06-17T07:14:50+00:00

from __future__ import annotations

from typing import List, Optional

from fastapi import FastAPI, Path, Query
from pydantic import conint

from .models import (
    DGGSJSON,
    Collection,
    CollectionList,
    ConfClasses,
    LandingPage,
    ZoneCollectionDGGSJSON,
    ZoneCollectionGeoJSON,
    ZoneGeoJSON,
    ZoneList,
)

app = FastAPI(
    title='WIP: OGC API DGGS ZoneQuery - process style',
    description='WARNING - This is work-in-progress.\n\nThe API is an evolution of https://app.swaggerhub.com/apis/aaime-sh/dggs-process/0.0.3#/DGGS%20access.\n\nBasic ideas:\n* The same API elements are used for a DGGS-RS service and a DGGS-Data service\n* In the case of a DGGS-RS service, the collections are the DGGS instances themselves,\n  and the returned features have no properties other than the geometry and resolution\n  (e.g., in GeoJSON the properties object will be ``null``)\n* In the case of a DGGS-Data service, the collections are the sample DGGS data (hence, made available in a particular DGGS instance, too), and the returned features have\n  actual values associated in the ``properties`` object.\n\nTo care for different use cases, three different output formats will be implemented\nfor each endpoint returning cells:\n* A classic GeoJSON output, with geometry being either the boundary or the center\n  point of the zone (to be controlled with a request parameter), for usage in classic\n  GIS tools. The longitudes ill eventually be extended outside of the -180,180\n  range to allow visualization by tools that cannot deal properly with dateline crossing.\n* A DGGSJSON output, small variation of the classic GeoJSON where the geometry is\n  replaced by an array of zone-ids, to be used in both zone oriented and feature oriented\n  API (e.g., the)\n* A plain array of DGGS zone ids, for cases where the attributes are not needed and data transfer compactness is paramount.\n\nQuestions, discussion topics:\n* Support for multiple DDGSs, we are using rHealPix and H3, to offer the\n  clients and DGGS data server at least a DGGS they are not already supporting natively\n* Is the API going to be sufficiently self describing that the clients\n  can figure out everything it needs by just walking the API, or will it need specific knowledge contained in an API profile (e.g, a profile for rHeadlPix, one for H3, cosider for example zoneId and how to determine them)\n* For parametric DDGSs (e.g., rHealPix) do we expose a specific instance as its own DGGS, or somehow expose the full parameters of the DGGS in each resource?\n* This API follows a process API, where most resources are a process and one needs to know valid values to hit them\n\n\nCHANGES\n* 2020-07-02 initial version\n* 2020-07-23 usage of zones instead of cells everywhere, extending to support also data DGGS servers.\n* 2021-06-15 addition of definitions for ZoneQuery operations',
    contact={'name': 'Robert Gibb', 'email': 'gibbr@landcareresearch.co.nz'},
    license={'name': 'OGC License', 'url': 'http://www.opengeospatial.org/legal/'},
    version='0.0.4',
)


@app.get('/', response_model=LandingPage)
def get_() -> LandingPage:
    """
    landing page
    """
    pass


@app.get('/collections', response_model=CollectionList)
def get_collections() -> CollectionList:
    """
    the list of supported collections
    """
    pass


@app.get('/collections/{collection_id}/describe', response_model=Collection)
def get_collections_collection_id_describe(
    collection_id: str = Path(..., alias='collectionId')
) -> Collection:
    """
    Describes a particular DGGS
    """
    pass


@app.get(
    '/collections/{collection_id}/zone', response_model=Union[ZoneGeoJSON, DGGSJSON]
)
def get_collections_collection_id_zone(
    collection_id: str = Path(..., alias='collectionId')
) -> Union[ZoneGeoJSON, DGGSJSON]:
    """
    Access the definition of a particular zone
    """
    pass


@app.get(
    '/collections/{collection_id}/zone/{zone_id}/buffer',
    response_model=Union[ZoneCollectionGeoJSON, ZoneCollectionDGGSJSON, ZoneList],
)
def get_collections_collection_id_zone_zone_id_buffer(
    collection_id: str = Path(..., alias='collectionId'),
    zone_id: str = Path(..., alias='zoneId'),
    distance: Optional[float] = None,
    project_to: Optional[List[str]] = Query(None, alias='projectTo'),
) -> Union[ZoneCollectionGeoJSON, ZoneCollectionDGGSJSON, ZoneList]:
    """
    Get the list of zones children of a given zone (should it return just a list of identifiers instead of a GeoJSON collection?)
    """
    pass


@app.get(
    '/collections/{collection_id}/zone/{zone_id}/child',
    response_model=Union[ZoneCollectionGeoJSON, ZoneCollectionDGGSJSON, ZoneList],
)
def get_collections_collection_id_zone_zone_id_child(
    collection_id: str = Path(..., alias='collectionId'),
    zone_id: str = Path(..., alias='zoneId'),
    inherit_id: Optional[bool] = Query(None, alias='inheritId'),
    levels: Optional[int] = None,
) -> Union[ZoneCollectionGeoJSON, ZoneCollectionDGGSJSON, ZoneList]:
    """
    Get the list of zones children of a given zone (should it return just a list of identifiers instead of a GeoJSON collection?)
    """
    pass


@app.get('/collections/{collection_id}/zone/{zone_id}/childOf', response_model=bool)
def get_collections_collection_id_zone_zone_id_child_of(
    collection_id: str = Path(..., alias='collectionId'),
    zone_id: str = Path(..., alias='zoneId'),
    zonal_id: str = Query(..., alias='zonalId'),
    inherit_id: Optional[bool] = Query(None, alias='inheritId'),
    project_to: Optional[List[str]] = Query(None, alias='projectTo'),
) -> bool:
    """
    Determine if the another ZonalID is a childOf the input ZonaID
    """
    pass


@app.get('/collections/{collection_id}/zone/{zone_id}/intersects', response_model=bool)
def get_collections_collection_id_zone_zone_id_intersects(
    collection_id: str = Path(..., alias='collectionId'),
    zone_id: str = Path(..., alias='zoneId'),
    zonal_id: str = Query(..., alias='zonalId'),
    project_to: Optional[List[str]] = Query(None, alias='projectTo'),
) -> bool:
    """
    Determine if the another ZonalID intersects with the ZonaID
    """
    pass


@app.get('/collections/{collection_id}/zone/{zone_id}/overlaps', response_model=bool)
def get_collections_collection_id_zone_zone_id_overlaps(
    collection_id: str = Path(..., alias='collectionId'),
    zone_id: str = Path(..., alias='zoneId'),
    zonal_id: str = Query(..., alias='zonalId'),
    project_to: Optional[List[str]] = Query(None, alias='projectTo'),
) -> bool:
    """
    Determine if the another ZonalID overlaps with the ZonaID
    """
    pass


@app.get('/collections/{collection_id}/zone/{zone_id}/parentOf', response_model=bool)
def get_collections_collection_id_zone_zone_id_parent_of(
    collection_id: str = Path(..., alias='collectionId'),
    zone_id: str = Path(..., alias='zoneId'),
    zonal_id: str = Query(..., alias='zonalId'),
    inherit_id: Optional[bool] = Query(None, alias='inheritId'),
    project_to: Optional[List[str]] = Query(None, alias='projectTo'),
) -> bool:
    """
    Determine if the another ZonalID is a parentOf the input ZonaID
    """
    pass


@app.get('/collections/{collection_id}/zone/{zone_id}/siblingOf', response_model=bool)
def get_collections_collection_id_zone_zone_id_sibling_of(
    collection_id: str = Path(..., alias='collectionId'),
    zone_id: str = Path(..., alias='zoneId'),
    zonal_id: str = Query(..., alias='zonalId'),
    inherit_id: Optional[bool] = Query(None, alias='inheritId'),
    project_to: Optional[List[str]] = Query(None, alias='projectTo'),
) -> bool:
    """
    Determine if the another ZonalID is a siblingOf the input ZonaID
    """
    pass


@app.get(
    '/collections/{collection_id}/zones',
    response_model=Union[ZoneCollectionGeoJSON, ZoneCollectionDGGSJSON, ZoneList],
)
def get_collections_collection_id_zones(
    collection_id: str = Path(..., alias='collectionId'),
    resolution: float,
    bbox: Optional[List[float]] = None,
    zone_id_list: Optional[List[str]] = Query(None, alias='zoneIdList'),
    limit: Optional[conint(ge=1, le=10000)] = 10,
) -> Union[ZoneCollectionGeoJSON, ZoneCollectionDGGSJSON, ZoneList]:
    """
    Access the list of zones in a given DGGS. Can list either all the zones, or a particular subset based on resolution, WGS84 bbox, or list of containing zones (e.g., polygon defined in DGGS terms)
    """
    pass


@app.get('/conformance', response_model=ConfClasses)
def get_conformance() -> ConfClasses:
    """
    information about specifications that this API conforms to (we may not need one)
    """
    pass
