# generated by fastapi-codegen:
#   filename:  dggs_zone_query-resolved.yaml
#   timestamp: 2021-06-17T07:14:50+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

import pydantic
# from pydantic import BaseModel, Field, conint
# from pydantic import Field, conint


class Type(Enum):
    Feature = 'Feature'


class Type1(Enum):
    FeatureCollection = 'FeatureCollection'


class Type2(Enum):
    FeatureCollection = 'FeatureCollection'


class Link(pydantic.BaseModel):
    href: str = pydantic.Field(..., example='http://data.example.com/buildings/123')
    rel: Optional[str] = pydantic.Field(None, example='alternate')
    type: Optional[str] = pydantic.Field(None, example='application/geo+json')
    hreflang: Optional[str] = pydantic.Field(None, example='en')
    title: Optional[str] = pydantic.Field(None, example='Trierer Strasse 70, 53115 Bonn')
    length: Optional[int] = None


class TimeStamp(pydantic.BaseModel):
    __root__: datetime = pydantic.Field(
        ...,
        description='This property indicates the time and date when the response was generated.',
        example='2017-08-17T08:05:32Z',
    )


class NumberMatched(pydantic.BaseModel):
    __root__: pydantic.conint(ge=0) = pydantic.Field(
        ...,
        description='The number of features of the feature type that match the selection\nparameters like `bbox`.',
        example=127,
    )


class NumberReturned(pydantic.BaseModel):
    __root__: pydantic.conint(ge=0) = pydantic.Field(
        ...,
        description='The number of features in the feature collection.\n\nA server may omit this information in a response, if the information\nabout the number of features is not known or difficult to compute.\n\nIf the value is provided, the value shall be identical to the number\nof items in the "features" array.',
        example=10,
    )


class RelativePositionEnum(Enum):
    Before = 'Before'
    After = 'After'
    Meets = 'Meets'
    MetBy = 'MetBy'
    Overlaps = 'Overlaps'
    OverlappedBy = 'OverlappedBy'
    Starts = 'Starts'
    StartedBy = 'StartedBy'
    During = 'During'
    Contains = 'Contains'
    Finishes = 'Finishes'
    FinishedBy = 'FinishedBy'
    Equals = 'Equals'
    In = 'In'
    Disjoint = 'Disjoint'


class RelativePosition(pydantic.BaseModel):
    __root__: List[RelativePositionEnum] = pydantic.Field(
        ...,
        description='a RelativePosition enumeration as defined in W3C/OGC 16-071r3 as one of',
    )


class LandingPage(pydantic.BaseModel):
    title: Optional[str] = pydantic.Field(None, example='Buildings in Bonn')
    description: Optional[str] = pydantic.Field(
        None,
        example='Access to data about buildings in the city of Bonn via a Web API that conforms to the OGC API Features specification.',
    )
    links: List[Link]


class Exception(pydantic.BaseModel):
    code: str
    description: Optional[str] = None


class ConfClasses(pydantic.BaseModel):
    conformsTo: List[str]


class Type3(Enum):
    Feature = 'Feature'


class Type4(Enum):
    Point = 'Point'


class PointGeoJSON(pydantic.BaseModel):
    type: Type4
    coordinates: List[float] = pydantic.Field(..., min_items=2)


class Type5(Enum):
    MultiPoint = 'MultiPoint'


class MultipointGeoJSON(pydantic.BaseModel):
    type: Type5
    coordinates: List[List[float]]


class Type6(Enum):
    LineString = 'LineString'


class Coordinate(pydantic.BaseModel):
    __root__: List[Any]


class LinestringGeoJSON(pydantic.BaseModel):
    type: Type6
    coordinates: List[Coordinate] = pydantic.Field(..., min_items=2)


class Type7(Enum):
    MultiLineString = 'MultiLineString'


class Coordinate1(pydantic.BaseModel):
    __root__: List[Any]


class MultilinestringGeoJSON(pydantic.BaseModel):
    type: Type7
    coordinates: List[List[Coordinate1]]


class Type8(Enum):
    Polygon = 'Polygon'


class Coordinate2(pydantic.BaseModel):
    __root__: List[Any]


class PolygonGeoJSON(pydantic.BaseModel):
    type: Type8
    coordinates: List[List[Coordinate2]]


class Type9(Enum):
    MultiPolygon = 'MultiPolygon'


class Coordinate3(pydantic.BaseModel):
    __root__: List[Any]


class MultipolygonGeoJSON(pydantic.BaseModel):
    type: Type9
    coordinates: List[List[List[Coordinate3]]]


class Type10(Enum):
    GeometryCollection = 'GeometryCollection'


class Collection(pydantic.BaseModel):
    id: str = pydantic.Field(
        ...,
        description="identifier of the the collection. In case it's a DGGS RS service, it will be the DGGS instance identifier, otherwise, it's going to be the data collection id.",
        example='TB16-Pix',
    )
    dggs_id: Optional[str] = pydantic.Field(
        None,
        alias='dggs-id',
        description='identifiers of the DGGS instance. For DGGS RS services, it will be the same as the id, for DGGS Data services, it identifiers the particular DGGS instance used.',
        example='TB16-Pix',
    )
    title: Optional[str] = pydantic.Field(
        None,
        description='human readable title of the collection',
        example='Testbed 16 DGGS reference system based on rHealPix',
    )
    description: Optional[str] = pydantic.Field(
        None,
        description='a description of the collection',
        example='Some description of the DGGS here',
    )
    resolutions: Optional[List[float]] = None
    links: List[Link] = pydantic.Field(
        ...,
        description='The list of links, e.g., to the operations provided by this DGGS collection.',
        example=[
            {'href': 'http://data.example.com/buildings', 'rel': 'item'},
            {
                'href': 'http://example.com/concepts/buildings.html',
                'rel': 'describedBy',
                'type': 'text/html',
            },
        ],
    )


class CollectionList(pydantic.BaseModel):
    links: List[Link]
    dggs_list: List[str] = pydantic.Field(..., alias='dggs-list')


class DGGSJSON(pydantic.BaseModel):
    id: Union[str, int]
    type: Type
    geometry: List[str] = pydantic.Field(
        ..., description='The geometry of the feature, as a list of DGGS zone ids'
    )
    properties: Dict[str, Any]
    links: Optional[List[Link]] = None


class ZoneCollectionDGGSJSON(pydantic.BaseModel):
    type: Type2
    features: List[DGGSJSON]
    links: Optional[List[Link]] = None
    timeStamp: Optional[TimeStamp] = None
    numberMatched: Optional[NumberMatched] = None
    numberReturned: Optional[NumberReturned] = None


class ZoneList(pydantic.BaseModel):
    zones: List[str]
    links: List[Link]
    timeStamp: Optional[TimeStamp] = None
    numberMatched: Optional[NumberMatched] = None
    numberReturned: Optional[NumberReturned] = None


class ZoneCollectionGeoJSON(pydantic.BaseModel):
    type: Type1
    features: List[ZoneGeoJSON]
    links: Optional[List[Link]] = None
    timeStamp: Optional[TimeStamp] = None
    numberMatched: Optional[NumberMatched] = None
    numberReturned: Optional[NumberReturned] = None


class FeatureGeoJSON(pydantic.BaseModel):
    type: Type3
    geometry: GeometryGeoJSON
    properties: Dict[str, Any]
    id: Optional[Union[str, int]] = None
    links: Optional[List[Link]] = None


class GeometryGeoJSON(pydantic.BaseModel):
    __root__: Union[
        PointGeoJSON,
        MultipointGeoJSON,
        LinestringGeoJSON,
        MultilinestringGeoJSON,
        PolygonGeoJSON,
        MultipolygonGeoJSON,
        GeometrycollectionGeoJSON,
    ]


class GeometrycollectionGeoJSON(pydantic.BaseModel):
    type: Type10
    geometries: List[GeometryGeoJSON]


class ZoneGeoJSON(FeatureGeoJSON):
    resolution: float
